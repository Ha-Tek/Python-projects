# -*- coding: utf-8 -*-
"""MOO_problem_Exercise1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fj8RCzZkLqUFGWVl44i_kcBFJ_HC8zE9

Hailemariam A. Tekile
                                         April 04, 2024


#         Solving Multiobjective Optimization Problem with Python

 Multi-Objective Optimization and Decision-Making with pymoo: Balancing Objectives, Finding Solutions

 https://pymoo.org

Exercise 1: Find solutions in pymoo using Compromise Programming and Pseudo-weights, visualize the results.

Min f1(x) = x1ˆ2+x2ˆ2+x3ˆ2

Max f2(x) = -(x1-1)ˆ2 - (x2-1)ˆ2 - (x3-1)ˆ2

 Subject to:

      g1 = x1 + x2 + x3 - 1 <= 0
      g2 = -3x1 + x2 + x3 - 4 >=0
      -10 <= x1 <= 10
      -10 <= x2 <= 10
      -10 <= x3 <= 10

 Source: https://www.udemy.com/course/multi-objective-optimization-with-python-bootcamp-a-z/?couponCode=KEEPLEARNING

Steps:
1.    Install pymoo and import all the required libraries accordingly.
2.   Develop a class and define a problem.
3. Initialize NSGA-II algorithm using below parameters:
  pop_size = 50,
  n_offsprings = 10,
  cross_over = SBX(prob=0.9, eta=20),
  mutation = PM(eta=25).
4. Use n_eval = 100 termination criteria.
5. Check out your objectives vector and visualize it in a 3d graph.
6. Normalize the objective vector using ideal point and nadir point.
7. Use Compromise Programming and Pseudo-weights methods to find the Optimum Point.
 Note! Imagine that the first objective is less important thatìn the other for us.
8. Visualise the results of each method and compare.
"""

!pip install pymoo #install pymoo on colab

"""# **Class Development**"""

import numpy as np
from pymoo.core.problem import ElementwiseProblem

class MyProblem(ElementwiseProblem):
    def __init__(self):
      super().__init__(n_var = 3,
                      n_obj = 2,
                      n_ieq_constr = 2,
                      xl = np.array([-10,-10,-10]),
                      xu = np.array([10,10,10]))
    def _evaluate(self,x,out,*args,**kwargs):
      f1 = (x[0]**2+x[1]**2+x[2]**2)
      f2 = (x[0]-1)**2 + (x[1]-1)**2 + (x[2]-1)**2 #changed sign to min

      g1 = x[0] + x[1] + x[2] - 1
      g2 = -3*x[0] + x[1] + x[2] - 4 #changed sign to <= due to pymoo nature

      out["F"] = [f1,f2]
      out["G"] = [g1,g2]

problem = MyProblem()

"""# **Initializing the algorithm**


"""

from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.operators.crossover.sbx import SBX #sbs - simulated binary crossover
from pymoo.operators.mutation.pm import PM  #pm - polynomial mutation

algorithm = NSGA2(
    pop_size = 50,
    n_offsprings = 10,
    sampling = FloatRandomSampling(),
    crossover = SBX(prob=0.9,eta=20), #prob - probability of crossover performed, eta - larger widespread of solution space
    mutation = PM(eta = 25), #controls the mutation rate
    eliminate_duplicates = True #duplicated solution is eliminated as we need a unique solution
)

"""Termination criteria"""

from pymoo.termination import get_termination
termination = get_termination("n_gen",100) #number of max generation

"""# **Optimization process**"""

from pymoo.optimize import minimize

res = minimize(problem,
               algorithm,
               termination,
               seed = 7, #to ensure the reproductivity of the result
               save_history = True,
               verbose = True) #progress information

"""# **Results and Visualization**"""

X = res.X
F = res.F

print(F) #print the two obj values f1 and f2

#visualization
from pymoo.visualization.scatter import Scatter

plot = Scatter(title = "Three Variables Solutions")
plot.add(F, color = "green")
plot.show()

"""# **Normailization**"""

ideal_point = F.min(axis=0) #axis=0 means in each row
nadir_point = F.max(axis=0) #nadir point is the worst objective values of the solutions of the entire Pareto-optimal set

ideal_point

nadir_point

import matplotlib.pyplot as plt

plt.figure(figsize=(8,6))
plt.scatter(F[:,0],F[:,1],s=50,facecolor='none',edgecolors = 'green') #scatter plot of f1 and f2
plt.scatter(ideal_point[0],ideal_point[1],facecolor='none',edgecolors = 'red',marker='*',s=100,label='Ideal Point') #ideal_point[0] indicates x-axis, s indicates size
plt.scatter(nadir_point[0],nadir_point[1],facecolor='none',edgecolors = 'black',marker='p',s=100,label='Nadir Point')
plt.title('Objective Space with Ideal and Nadir Points')
plt.legend()
plt.show()

#normalized vector of objectives F
nF = (F-ideal_point) / (nadir_point - ideal_point) #normalized F

fl = nF.min(axis=0) #Lower f on each row
fu = nF.max(axis=0) #Upper f on each row

print(f"Scale f1: [{fl[0]},{fu[0]}]")
print(f"Scale f2: [{fl[1]},{fu[1]}]")

plt.figure(figsize=(8,6))
plt.scatter(nF[:,0],nF[:,1],s=50,facecolor='none',edgecolors = 'green')
plt.title('Normalized Objective Vector')
plt.show()

"""# **Decision making using Compromise Programming**"""

from pymoo.decomposition.asf import ASF #ASF - Augmented Scalarization Function
decomp = ASF()

Weights = np.array([0.2,0.8]) #objective f1 is 20% important and f2 is 80% important in our main problem (based on the priority of our objective)

#optimum index, where the optimal value is located
opt_index = decomp.do(nF,1/Weights).argmin() #returns the index of the minimum value; the reciprocal of the weights is due to the decomposition module

print(f"Best ASF: \n Opt_index = {opt_index} \n F = {F[opt_index]}")

#display the optimal solution in a red color
plt.figure(figsize=(8,6))
plt.scatter(F[:,0],F[:,1],s=50,facecolor='none',edgecolors = 'green')
plt.scatter(F[opt_index,0],F[opt_index,1],marker = 'x',color='red',s=100)
plt.show()

# Values of THE decision variables x1, x2, x3
print(X)

# Optimal solution based on the optimum index 21
X_Optimum = X[21,:]

print(X_Optimum)

"""# **Decision Making Using Pseudo-Weights**"""

from pymoo.mcdm.pseudo_weights import PseudoWeights

Weights = np.array([0.2,0.8])

Opt_Index2 = PseudoWeights(Weights).do(nF)

print(f"Best Pseudo Weights: \n Opt_Index2 = {Opt_Index2} \n F = {F[Opt_Index2]}")

plt.figure(figsize=(8,6))
plt.scatter(F[:,0],F[:,1],s=50,facecolor='none',edgecolors = 'green')
plt.scatter(F[Opt_Index2,0],F[Opt_Index2,1],marker = 'x',color='red',s=100)
plt.show()

"""# Comparison

No solution change in both methods regarding the above example.
"""